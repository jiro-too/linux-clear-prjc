/**
 * @file configurator.c
 * @author Soham Nandy (you@domain.com)
 * @brief This file is part of linux-clear-prjc.
 * @version 1
 * @date 2022-09-25
Developed as a helper to build custom kernels.
This product includes software developed by Soham Nandy

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
 * @copyright Soham Nandy (c) 2022
 *
 */

#ifdef __cplusplus
#pragma warning("Not recomended to compile the file with a C++ compiler. Consider using a C compiler");
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <signal.h>
#include <zlib.h>
#include <dirent.h>
#include <unistd.h>
#include <errno.h>
#include <setjmp.h>
#include "configurator.h"
#include "patcher.h"

extern int zcat_impl(FILE *input, FILE *output);
extern int file_copy(char *source, char *destination);
extern int file_check(int argc, ...);

bool _extraction;
bool _custom_config;
bool _use_dist_config;
bool _interactive;
bool _custom_kernel;
bool _v_flag = false;
bool _force;

static const char *program_name = "kernel-configurator";
char *g_conf_gz;                      /* Gzippled config path location */
char *g_oconfig = "../linux/.config"; /*Output config to: */
char *g_iconfig;                      /* Input config file location */

char *kernel_path = "../linux";
char *kernel_version = "5.19.10";

/**
 * @brief prints to stderr, used to errors.
 *
 * @param fmt character string
 * @param ... N number of arguments to use with fmt.
 */
void eprintf(char *fmt, ...)
{
    // va_list is a special type that allows hanlding of variable
    // length parameter list
    va_list args;
    va_start(args, fmt);

    vfprintf(stderr, fmt, args);
}
/**
 * @brief Verbose print if _v_flag is set
 *
 * @param fmt character string
 * @param ... N number of arguments to use with fmt.
 */
void _vprintf(char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);

    if (_v_flag)
    {
        vfprintf(stdout, fmt, args);
        fflush(stdout);
    }
}

static void usage()
{
    fprintf(stderr,
            "Usage:\n\
-i \tCustom kernel config file location\n"
            "-e \tAuto-extracts from /proc/config.gz\n"
            "-g \tSame as -e but allows you to specify custom path\n"
            "-h \tShows this message\n"
            "-o \tChange final .config option output location\n\t\
Can be used to review files generated by /proc/config.gz or specify a location\n\t\
to copy parameters passed by -i\n"
            "-k \tChange kernel directory. Overrides -o \n"
            "-b \tMake kernel specified at kernel directory\n"
            "-a \tMake kernel with a distribution's kernel config\n"
            "-f \tStart making kernel without any user prompt\n");
    exit(1);
}

static void *terminate_addr = NULL;

/**
 * @brief Flush stdout and stderr, exit following fprintf command to print
 * signal that was caught.
 *
 * @param signo Signal sent to program.
 */
static void terminate_intr(int signo)
{
    fflush(stdout);
    fprintf(stderr, "\n\nInterrupted with %d\n", signo);
    fflush(stderr);
    if (terminate_addr)
        longjmp(terminate_addr, 1);
    exit(1);
}
/**
 * @brief Captures term signals sent to the program.
 * Redirects to terminate_intr
 *
 * @param term_addr Misc option. Defaults to *0x0
 */
static void capture_terminate(jmp_buf term_addr)
{
    terminate_addr = term_addr;
    signal(SIGHUP, terminate_intr);
    signal(SIGINT, terminate_intr);
    signal(SIGPIPE, terminate_intr);
    signal(SIGTERM, terminate_intr);
    signal(SIGUSR1, terminate_intr);
    signal(SIGUSR2, terminate_intr);
}
/**
 * @brief Return all capture handles to system.
 *
 */
static void uncapture_terminate(void)
{
    terminate_addr = NULL;
    signal(SIGHUP, SIG_DFL);
    signal(SIGINT, SIG_DFL);
    signal(SIGPIPE, SIG_DFL);
    signal(SIGTERM, SIG_DFL);
    signal(SIGUSR1, SIG_DFL);
    signal(SIGUSR2, SIG_DFL);
}

/**
 * @brief Prompt user to choose kernel version. Lists optios
 *
 */
static void
choose_kver()
{
    capture_terminate(NULL);
    if (_custom_kernel)
    {

        fprintf(stdout,
                (
                    "\nChoose your exact kernel versions:\n"
                    "1.\t5.19.0\n"
                    "2.\t5.19.1\n"
                    "3.\t5.19.2\n"
                    "4.\t5.19.3\n"
                    "5.\t5.19.4\n"
                    "6.\t5.19.5\n"
                    "7.\t5.19.6\n"
                    "8.\t5.19.7\n"
                    "9.\t5.19.8\n"
                    "10.\t5.19.9\n"
                    "11.\t5.19.10\n"
                    "12.\t5.19.11\n"));

        int kver_option = input();

        switch (kver_option)
        {
        case 1:
            kernel_version = "5.19.0";
            break;
        case 2:
            kernel_version = "5.19.1";
            break;
        case 3:
            kernel_version = "5.19.2";
            break;
        case 4:
            kernel_version = "5.19.3";
            break;
        case 5:
            kernel_version = "5.19.4";
            break;
        case 6:
            kernel_version = "5.19.5";
            break;
        case 7:
            kernel_version = "5.19.6";
            break;
        case 8:
            kernel_version = "5.19.7";
            break;
        case 9:
            kernel_version = "5.19.8";
            break;
        case 10:
            kernel_version = "5.19.9";
            break;
        case 11:
            kernel_version = "5.19.10";
            break;
        case 12:
            kernel_version = "5.19.11";
            break;
        default:
            eprintf("Wrong option\n");
            exit(1);
        }
    }
    return;
}

/**
 * @brief
 *      -> Copies kernel to boot directory
 *      -> Regenerates Grub configuration
 *
 */

static void
install_kernel()
{
    char bzImage[2048];
    char SystemMap[2048];
    sprintf(bzImage, "%s/arch/x86_64/boot/bzImage", kernel_path); // path to kernel binary
    sprintf(SystemMap, "%s/System.map", kernel_path);             // path to kernel system map

    _vprintf("Argumets passed to bzImage: %s\n\
            Arguments passed to systemMap: %s\n",
             bzImage, SystemMap);
    int opt = true;
    printf("\nDo you want to copy kernel images to /boot ? [0/1]\n");
    if (!_force)
    {
        opt = input();
    }
    if (opt)
    {
        _vprintf("\nkernel version = %s\n", kernel_version);

        // Check if files exist before attempting to copy.

        char copyCommandbzImage[2048];
        char copyCommandSystemMap[2048];
        /*
         * Copy command is used due to easier version and kernel name management.
         * Copies from kernel_dir/arch/x86_64/boot/bzImage to /boot/vmlinuz-kver-kname
         * Retrieves kname using a combination of grep, sed and tr
         */
        fflush(stdout);
        sprintf(copyCommandbzImage,
                "cp %s\
/boot/vmlinuz-%s\
$(/bin/cat %s/.config | grep CONFIG_LOCALVERSION= | sed -r 's/^CONFIG_LOCALVERSION=//g' | tr -d '\"')",
                bzImage, kernel_version, kernel_path);

        /*
         * Copy command is used due to easier version and kernel name management.
         * Copies from kernel_dir/System.map to /boot/System.map-kver-kname
         * Retrieves kname using a combination of grep, sed and tr
         */
        sprintf(copyCommandSystemMap,
                "cp %s\
/boot/vmlinuz-%s\
$(/bin/cat %s/.config | grep CONFIG_LOCALVERSION= | sed -r 's/^CONFIG_LOCALVERSION=//g' | tr -d '\"')",
                SystemMap, kernel_version, kernel_path);

        printf("%s", copyCommandbzImage);

        /*
         * Generates grub config at /boot/grub/grub.cfg using the grub-mkconfig config. Adds kernel entry to /boot
         */
        printf("\nDo you want to regenerate grub-mkconfig? [0/1] \n");
        if (!_force)
        {
            opt = input();
        }
        if (opt)
        {
            system("grub-mkconfig -o /boot/grub/grub.cfg");
        }
    }
}

/**
 * @brief Starts building the kernel
 *
 */
static void
make_kernel()
{
    capture_terminate(NULL);
    choose_kver();

    /*
     * Create paths for 5 files. The Makefile and Kconfig will be scanned to see if directory exists
     * bzImage,SystemMap and config is used to move files.
     */

    char makefile[2048];
    char Kconfig[2048];
    sprintf(makefile, "%s/Makefile", kernel_path); // path to kernel Makefile
    sprintf(Kconfig, "%s/Kconfig", kernel_path);   // path to Kconfig

    if (file_check(2, makefile, Kconfig) == 0)
    {
        _vprintf("[+] Checking important files\n");
    }
    else
    {
        eprintf("Error checking files\n");
        exit(1);
    }

    if (_custom_kernel)
    {
        printf("Custom kernel location detected. Do you want to patch it? [0/1]\n");
        int patch = input();
        if (patch)
            patch_prompt(kernel_path);
    }

    printf("\nDo you want to call menuconfig? [0/1] \n");
    int menuconfig_choice = input();

    if (menuconfig_choice)
    {
        char menuconfigCommand[2048];
        sprintf(menuconfigCommand,
                "cd %s &&\
                make olddefconfig &&\
                make menuconfig",
                kernel_path);
        system(menuconfigCommand);
    }

    int opt = true;
    printf("Make the kernel now? [0-no 1-yes]\n");
    if (!_force)
    {
        opt = input();
    }

    if (opt)
    {
        char command[2048];
        printf("Generating kernel, please wait...");
        fflush(stdout);
        sprintf(command,
                "\
                cd %s && \
                make -j\
                $(/bin/cat /proc/cpuinfo | grep processor | wc -l)  &&\
                make modules_install -j\
                $(/bin/cat /proc/cpuinfo | grep processor | wc -l)",
                kernel_path);

        _vprintf("Command to generate %s\n", command);
        system(command);
        install_kernel();
        fflush(stdout);
    }

    uncapture_terminate();
    exit(0);
}

/**
 * @brief Safe integer input in C
 * Terminates if EOF error/ Number exceeding maximum possible limits / \0 or \n in number
 * non numeric number
 *
 * @return long number taken in input.
 */
long input()
{
    char buf[25];
    char *end_ptr;
    long num_long;

    if (fgets(buf, sizeof(buf), stdin) == NULL)
    {
        if (puts("[x] EOF or read error\n") == EOF)
        {
            exit(1);
        }
    }

    else
    {
        errno = 0;
        num_long = strtol(buf, &end_ptr, 10);
    }

    if (ERANGE == errno)
    {
        puts("[x] Number out of range");
        exit(1);
    }
    else if (end_ptr == buf)
    {
        puts("[x] Not valid numeric input\n");
        exit(1);
    }
    else if ('\n' != *end_ptr && '\0' != *end_ptr)
    {
        puts("[x] Extra characters on input line\n");
        exit(1);
    }
    return num_long;
}

/**
 * @brief Get the config.gz from /proc/
 * Extract it using zcat_impl implemented in filehelper.c
 *
 * @return 1 if file is not in .gz format
 * @return 2 if file is not in .gz format
 * @return 3 if the file cannot be accessed
 */
static bool
get_proc_gz()
{
    FILE *inFile = fopen(g_conf_gz, "rb");
    FILE *outFile = fopen(g_oconfig, "w+");

    char *extensionMark = strstr(g_conf_gz, ".gz");

    if (extensionMark == NULL)
    {
        fprintf(stderr, "File %s is not in .gz format\n", g_conf_gz);
        return 1;
    }

    if (*extensionMark != g_conf_gz[strlen(g_conf_gz) - 3])
    {
        fprintf(stderr, "File is not in .gz format\n");
        return 2;
    }

    inFile = fopen(g_conf_gz, "rb");

    if (inFile == NULL)
    {
        fprintf(stderr, "Cannot open file %s\n", g_conf_gz);
        return 3;
    }
    zcat_impl(inFile, outFile);
    return 0;
}

/**
 * @brief Uses distribution config
 *
 */
static void
dist_config()
{
    #define ARCH_DEFAULT_PATH "./dist-config/arch-config"
    #define GENTOO_DEFAULT_PATH "./dist-config/gentoo-dist-config"
    fprintf(stdout, (
                        "Choices:\n"
                        "1. Arch Linux\n"
                        "2. Gentoo Linux distribution kernel\n"));

    int choice = input();
    if (choice > 2)
    {
        printf("[x] Number out of range\n");
        exit(1);
    }

    switch (choice)
    {
    case 1:
        printf("Arch linux config selected\n");
        file_copy(ARCH_DEFAULT_PATH, g_oconfig);
        break;
    case 2:
        printf("Gentoo-dist-config selected\n ");
        file_copy(GENTOO_DEFAULT_PATH, g_oconfig);
        break;
    default:
        printf("Unrecognized option\n");
        exit(1);
    }
    make_kernel();
    exit(0);
}

/**
 * @brief Main function called in the beginning. Parses args
 *
 * @param argc number of arguments
 * @param argv argument vector
 * @return int exit code
 */
int main(int argc, char **argv)
{

    if (argc > 1)
    {
        int opt;
        while ((opt = getopt(argc, argv, "vi:o:g:k:ehfa")) != EOF)
        {
            switch (opt)
            {
            case 'v':
                _v_flag++;
                continue;
            case 'h':
                usage();

            case 'i':
                _custom_config++;
                _vprintf("Kernel config argument found: %s\n", optarg);
                _extraction = false;
                g_iconfig = optarg;
                continue;
            case 'o':
                _vprintf("Final path change to %s\n", optarg);
                g_oconfig = optarg;
                continue;
            case 'k':
                _vprintf("Overriding kernel directory to %s\n", optarg);
                DIR *dir = opendir(optarg);
                if (dir)
                    closedir(dir);
                else if (ENOENT == errno)
                {
                    eprintf("Kernel directory doesnt exist\n");
                    exit(1);
                }
                kernel_path = optarg;
                // Sets config output path to kernel_dir/.config
                char path_to_kernel_config[1024];
                sprintf(path_to_kernel_config, "%s/.config", kernel_path);
                g_oconfig = path_to_kernel_config;

                _custom_kernel++;

                continue;
            case 'a':
                _vprintf("Configuring kernel with a distribution config\n");
                _use_dist_config++;
                continue;
            case 'f':
                printf("Force option set. Saying yes to all make and install prompts\n");
                _force++;
                break;
#ifdef CUSTOM_GZ_FILE
            case 'g':
                _extraction = 1;
                _vprintf("[+] Override config.gz file location to: %s\n", optarg);
                g_conf_gz = optarg;
                continue;

            case 'e':
                _extraction = 1;
                _vprintf("Using default /proc/config.gz \n");
                g_conf_gz = "/proc/config.gz";
                get_proc_gz();
                break;
#endif
            }

            fflush(stdout);
            break;
        }
    }
    SET_BINARY_MODE(stdio);
    SET_BINARY_MODE(stdout);
    if (getuid() != 0)
    {
        printf("Requires root access\n");
        exit(1);
    }

    int ret = 0;

    if (_use_dist_config)
    {
        dist_config();
    }
    if (_custom_config)
    {
        if (file_check(2, g_iconfig, g_oconfig) == 0)
        {
            ret = file_copy(g_iconfig, g_oconfig);
            if (ret == 0)
            {
                make_kernel();
            }
        }
    }
    else if (_extraction)
    {
        ret = get_proc_gz();
        if (ret == 0)
        {
            make_kernel();
        }
    }

    if (ret != 0)
    {
        printf("[x] Couldnt find config.\n Dropping to distribution choices\n");
        dist_config();
    }

    printf("Unable to parse arguments\n");
    dist_config();
    return 0;
}
