/*
 * This file is part of linux-clear-prjc.
 *
 * Developed as a helper to build custom kernels.
 * This product includes software developed by Soham Nandy @ DPSRPK 
 * (soham.nandy2006@gmail.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#ifdef __cplusplus
    #pragma warning("Not recomended to compile the file with a C++ compiler. Consider using a C compiler");
#endif


#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <signal.h>
#include <zlib.h>
#include <dirent.h>
#include <unistd.h>
#include <errno.h>
#include <setjmp.h>
#include "configurator.h"
#include "patcher.h"


extern int zcat_impl(FILE *input,FILE *output);
extern int file_copy(char *source,char *destination);
extern int file_check(int argc,...);

bool _extraction;
bool _custom_config;
bool _use_dist_config;
bool _interactive;
bool _custom_kernel;
bool _v_flag;
bool _force;


static const char *program_name = "kernel-configurator";
char *g_conf_gz; /* Gzippled config path location */
char *g_oconfig = "../linux/.config"; /*Output config to: */
char *g_iconfig; /* Input config file location */

char *kernel_path = "../linux";
char *kernel_version = "5.19.10";


void 
eprintf(char *fmt , ...)
{
     // va_list is a special type that allows hanlding of variable
    // length parameter list
    va_list args;
    va_start(args, fmt);

    vfprintf (stderr, fmt, args);
}

void 
_vprintf (char *fmt , ...)
{
    va_list args;
    va_start(args,fmt);

    if (_v_flag)
    {
        vfprintf(stdout,fmt,args);
    }
}

/**
 *
 * Prints help message. Static function can only be called from configurator object.
*/
static void usage(){
    fprintf(stderr, 
"Usage:\n\
-i \tCustom kernel config file location\n"
"-e \tAuto-extracts from /proc/config.gz\n"
"-g \tSame as -e but allows you to specify custom path\n"
"-h \tShows this message\n"
"-o \tChange final .config option output location\n\t\
Can be used to review files generated by /proc/config.gz or specify a location\n\t\
to copy parameters passed by -i\n"
"-k \tChange kernel directory. Overrides -o \n"
"-b \tMake kernel specified at kernel directory\n"
"-a \tMake kernel with a distribution's kernel config\n"
"-f \tStart making kernel without any user prompt\n"
    );
    exit(1);
} 
static void *terminate_addr = NULL;

static void terminate_intr(int signo)
{
	fflush(stdout);
	fprintf(stderr, "\n\nInterrupted with %d\n",signo);
	fflush(stderr);
	if (terminate_addr)
		longjmp(terminate_addr,1);
	exit(1);
}

static void capture_terminate(jmp_buf term_addr)
{
	terminate_addr = term_addr;
	signal (SIGHUP, terminate_intr);
	signal (SIGINT, terminate_intr);
	signal (SIGPIPE, terminate_intr);
	signal (SIGTERM, terminate_intr);
	signal (SIGUSR1, terminate_intr);
	signal (SIGUSR2, terminate_intr);
}

static void uncapture_terminate(void)
{
	terminate_addr = NULL;
	signal (SIGHUP, SIG_DFL);
	signal (SIGINT, SIG_DFL);
	signal (SIGPIPE, SIG_DFL);
	signal (SIGTERM, SIG_DFL);
	signal (SIGUSR1, SIG_DFL);
	signal (SIGUSR2, SIG_DFL);
}

/**
 * Main function to execute commands to build the kernel. Checks whether custom
 * kernel flag is set, otherwise defaults to upstream version.
 *
 * Checks if the kernel directory has important files present to build the kernel.
 * Prompts the user:
 *          -> Whether to patch the kernel or not? 
 *              * Calls patch_prompt() if affirmative
 *          
 *          -> Whether to call `make menuconfig` to open ncurses config menu.
 *              * Also calls `make oldconfig` to ensure all options are set properly.
 *
 *          -> Whether to copy the compiled kernel binaries to /boot/
 *          
 *          -> Whether to regenerate grub configuration.
 *
 * 
 * @param
 *      None
 *
 * @return void
 *
*/

static void 
make_kernel()
{
    capture_terminate(NULL); 
    if (_custom_kernel){

    
    fprintf(stdout,
            (
"\nChoose your exact kernel versions:\n"
"1.\t5.19.0\n"
"2.\t5.19.1\n"
"3.\t5.19.2\n"
"4.\t5.19.3\n"
"5.\t5.19.4\n"
"6.\t5.19.5\n"
"7.\t5.19.6\n"
"8.\t5.19.7\n"
"9.\t5.19.8\n"
"10.\t5.19.9\n"
"11.\t5.19.10\n"
         ));

    int kver_option=input();

    switch(kver_option){
        case 1:
            kernel_version="5.19.0";
            break;
        case 2:
            kernel_version="5.19.1";
            break;
        case 3:
            kernel_version="5.19.2";
            break;
        case 4:
            kernel_version="5.19.3";
            break;
        case 5:
            kernel_version="5.19.4";
            break;
        case 6:
            kernel_version="5.19.5";
            break;
        case 7:
            kernel_version="5.19.6";
            break;
        case 8:
            kernel_version="5.19.7";
            break;
        case 9:
            kernel_version="5.19.8";
            break;
        case 10:
            kernel_version="5.19.9";
            break;
        case 11:
            kernel_version="5.19.10";
            break;
        default:
            eprintf("Wrong option\n");
            exit(1);
    }
}
    
    
    /*
     * Create paths for 5 files. The Makefile and Kconfig will be scanned to see if directory exists
     * bzImage,SystemMap and config is used to move files.
    */

    char makefile[2048];
    char Kconfig[2048];
    char bzImage[2048];
    char SystemMap[2048];
    sprintf(makefile,"%s/Makefile",kernel_path); // path to kernel Makefile 
    sprintf(Kconfig,"%s/Kconfig",kernel_path); // path to Kconfig  
    sprintf(bzImage,"%s/arch/x86_64/bzImage",kernel_path); // path to kernel binary 
    sprintf(bzImage,"%s/System.map",kernel_path); // path to kernel system map


    if (file_check(2,makefile,Kconfig) == 0)
    {
        _vprintf("[+] Checking important files\n");
    }
    else
    {
        eprintf("Error checking files\n");
        exit(1);
    }

    if (strcmp(kernel_path,"../linux") !=0)
    {
        printf("Custom kernel location detected. Do you want to patch it? [0/1]\n");
        int patch=input();
        if (patch) patch_prompt(kernel_path); 
    }
    
    printf("\nDo you want to call menuconfig? [0/1] \n");
    int menuconfig_choice=input();
    
    if (menuconfig_choice && !_force){
        char menuconfigCommand[2048];
        sprintf(menuconfigCommand,
                "cd %s &&\
                make olddefconfig &&\
                make menuconfig"
                ,kernel_path);
        system(menuconfigCommand);
    }
    
    int opt;
    printf("Make the kernel now? [0-no 1-yes]\n");
    if (!_force)
    {
        opt=input();

    }
    
    if (opt){
        char command[2048];
        printf("Generating kernel, please wait...");
        fflush(stdout);
        sprintf(command,
                "\
                cd %s && \
                make -j\
                $(/bin/cat /proc/cpuinfo | grep processor | wc -l)  &&\
                make modules_install -j\
                $(/bin/cat /proc/cpuinfo | grep processor | wc -l)"
                ,kernel_path);

        _vprintf("Command to generate %s\n",command);
        system(command);

        printf("\nDo you want to copy kernel images to /boot ? [0/1]\n");
        if (!_force){
            opt=input();
        }
        if (opt)
        {
            _vprintf("\nkernel version = %s\n",kernel_version);

            // Check if files exist before attempting to copy.
            
            if (file_check(2,bzImage,SystemMap) == -1){
                eprintf("\nUnable to find kernel binaries.Aborting\n");
                exit(1);
            }
            char copyCommandbzImage[2048];
            char copyCommandSystemMap[2048];
            /*
                * Copy command is used due to easier version and kernel name management.
                * Copies from kernel_dir/arch/x86_64/boot/bzImage to /boot/vmlinuz-kver-kname
                * Retrieves kname using a combination of grep, sed and tr
            */

            sprintf(copyCommandbzImage,
                    "cp %s\
                    /boot/vmlinuz-%s\
                    $(/bin/cat %s/.config | grep CONFIG_LOCALVERSION= | sed -r 's/^CONFIG_LOCALVERSION=//g' | tr -d '\"')", 
                    bzImage,kernel_version,kernel_path);

            /*
                * Copy command is used due to easier version and kernel name management.
                * Copies from kernel_dir/System.map to /boot/System.map-kver-kname
                * Retrieves kname using a combination of grep, sed and tr
            */
            sprintf(copyCommandSystemMap,
                    "cp %s\
                    /boot/vmlinuz-%s\
                    $(/bin/cat %s/.config | grep CONFIG_LOCALVERSION= | sed -r 's/^CONFIG_LOCALVERSION=//g' | tr -d '\"')",
                    SystemMap,kernel_version,kernel_path);
                        
            system(copyCommandbzImage);
            fflush(stdout);
        }
        

        /*
         * Generates grub config at /boot/grub/grub.cfg using the grub-mkconfig config. Adds kernel entry to /boot
        */
        printf("\nDo you want to regenerate grub-mkconfig? [0/1] \n");
        if (!_force){
            opt=input();
        }
        if (opt){
            system("grub-mkconfig -o /boot/grub/grub.cfg");
        }
    }
    uncapture_terminate();
    exit(0);
}

long input(){
  char buf[25];
  char *end_ptr;
  long num_long;

  if (fgets(buf,sizeof(buf),stdin) == NULL){
    if (puts("[x] EOF or read error\n") == EOF){exit(1);}
  }

  else{
    errno = 0;
    num_long = strtol(buf, &end_ptr,10);
  }

  if (ERANGE == errno){
    puts("[x] Number out of range");
    exit(1);
  }
  else if (end_ptr == buf){
    puts("[x] Not valid numeric input\n");
    exit(1);
    
  }
  else if ('\n' != *end_ptr && '\0' != *end_ptr) {
    puts("[x] Extra characters on input line\n");
    exit(1);
  }
  return num_long;
}


static bool get_proc_gz(){
    FILE *inFile = fopen(g_conf_gz,"rb");
    FILE *outFile = fopen(g_oconfig,"w+");

    char *extensionMark = strstr( g_conf_gz, ".gz" );

    if( extensionMark == NULL )
    {
        fprintf(stderr, "File %s is not in .gz format\n",g_conf_gz);
        return 1;
    }

    if( *extensionMark != g_conf_gz[strlen(g_conf_gz)-3] )
    {
        fprintf(stderr, "File is not in .gz format\n");
        return 2;
    }

    inFile = fopen(g_conf_gz, "rb");

    if( inFile == NULL )
    {
        fprintf(stderr, "Cannot open file %s\n", g_conf_gz);
        return 3;
    }
    zcat_impl(inFile,outFile);
    make_kernel();
    return 0;
}


static void dist_config()
{
    fprintf(stdout,(
"Choices:\n"
"1. Arch Linux\n"
"2. Gentoo Linux distribution kernel\n"
    ));

    int choice = input();
    if (choice > 2){
        printf("[x] Number out of range\n");exit(1);
    }

    switch(choice){
        case 1:
            printf("Arch linux config selected\n");
            file_copy("./arch-config",g_oconfig);
            break;
        case 2:
            printf("Gentoo-dist-config selected\n ");
            file_copy("./gentoo-dist-config",g_oconfig);
            break;
        default:
            printf("Unrecognized option\n");
            exit(1);
    }
    make_kernel();
    exit(0);
}

int main(int argc,char **argv)
{

    if (argc > 1){  
    int opt;
    while ((opt = getopt(argc,argv,"i:o:g:k:ehfa")) != EOF){
        switch(opt){
        case 'h':
            usage();

        case 'i':
            _custom_config++;
            _vprintf("Kernel config argument found: %s\n",optarg);
            _extraction = false;
            g_iconfig=optarg;
            continue;
        case 'o':
            _vprintf("Final path change to %s\n",optarg);
            g_oconfig=optarg;
            continue; 
        case 'k':
            _vprintf("Overriding kernel directory to %s\n",optarg);
            DIR *dir = opendir(optarg);
            if (dir) closedir(dir);
            else if(ENOENT == errno)
            {
                eprintf("[x] Kernel directory doesnt exist\n");
                exit(1);
            }
            kernel_path=optarg;
            // Sets config output path to kernel_dir/.config
            char path_to_kernel_config[1024];
            sprintf(path_to_kernel_config,"%s/.config",kernel_path);
            g_oconfig=path_to_kernel_config;

            _custom_kernel++;
            
            continue;
        case 'a':
            _vprintf("Configuring kernel with a distribution config\n");
            _use_dist_config++;
            continue;
        case 'f':
            printf("Force option set. Saying yes to all make and install prompts\n");
            _force++;
            break;
#ifdef CUSTOM_GZ_FILE
        case 'g':
            _extraction=1;
            _vprintf("[+] Override config.gz file location to: %s\n",optarg);
            g_conf_gz=optarg;
            continue; 
        
        case 'e':
            _extraction=1;
            _vprintf("Using default /proc/config.gz \n");
            g_conf_gz = "/proc/config.gz";
            get_proc_gz();
            break;
#endif
        }

    fflush(stdout);
    break;
     }
  }
  SET_BINARY_MODE(stdio);
  SET_BINARY_MODE(stdout);
    if (getuid() !=0){
        printf("Requires root access\n");
        exit(1);
    }

  int ret=0;

  if (_use_dist_config){
      dist_config();
  }
  if (_custom_config){
      ret = file_copy(g_iconfig,g_oconfig);
      make_kernel();
  }
  else if (_extraction){
      ret = get_proc_gz();
  }


  if (ret != 0)
  {
      printf("[x] Couldnt find config.\n Dropping to distribution choices\n");
      dist_config();
  }

  eprintf("No flags specified\n Exiting");
  usage();

  return 0;
  
}

